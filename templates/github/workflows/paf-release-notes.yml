# PAF Release Notes Workflow
# Automatically generates release notes from PRs

name: PAF Release Notes

on:
  release:
    types: [created]
  push:
    tags:
      - 'v*'

jobs:
  release-notes:
    name: Generate Release Notes
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Release Notes
        uses: actions/github-script@v7
        with:
          script: |
            const tag = context.ref.replace('refs/tags/', '');
            
            // Get the previous tag
            const { data: tags } = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 10
            });
            
            const currentTagIndex = tags.findIndex(t => t.name === tag);
            const previousTag = tags[currentTagIndex + 1]?.name || '';
            
            // Get commits between tags
            let compareBase = previousTag || tags[tags.length - 1]?.name;
            
            // Get PRs merged since last release
            const { data: pulls } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed',
              sort: 'updated',
              direction: 'desc',
              per_page: 100
            });
            
            // Filter PRs merged after previous release
            const mergedPRs = pulls.filter(pr => pr.merged_at);
            
            // Categorize PRs by labels
            const categories = {
              'ðŸ”’ Security': [],
              'âœ¨ Features': [],
              'ðŸ› Bug Fixes': [],
              'âš¡ Performance': [],
              'ðŸ“š Documentation': [],
              'ðŸ”§ Maintenance': [],
              'ðŸ¤– Agent Findings': [],
              'ðŸŽ‰ Other': []
            };
            
            for (const pr of mergedPRs) {
              const labels = pr.labels.map(l => l.name);
              let categorized = false;
              
              if (labels.includes('security')) {
                categories['ðŸ”’ Security'].push(pr);
                categorized = true;
              }
              if (labels.includes('feature')) {
                categories['âœ¨ Features'].push(pr);
                categorized = true;
              }
              if (labels.includes('bug')) {
                categories['ðŸ› Bug Fixes'].push(pr);
                categorized = true;
              }
              if (labels.includes('performance')) {
                categories['âš¡ Performance'].push(pr);
                categorized = true;
              }
              if (labels.includes('documentation')) {
                categories['ðŸ“š Documentation'].push(pr);
                categorized = true;
              }
              if (labels.includes('tech-debt') || labels.includes('refactoring')) {
                categories['ðŸ”§ Maintenance'].push(pr);
                categorized = true;
              }
              if (labels.includes('ðŸ¤– agent') || labels.includes('finding')) {
                categories['ðŸ¤– Agent Findings'].push(pr);
                categorized = true;
              }
              
              if (!categorized) {
                categories['ðŸŽ‰ Other'].push(pr);
              }
            }
            
            // Generate release notes
            let releaseNotes = `# Release ${tag}\n\n`;
            
            for (const [category, prs] of Object.entries(categories)) {
              if (prs.length > 0) {
                releaseNotes += `## ${category}\n\n`;
                for (const pr of prs) {
                  releaseNotes += `- ${pr.title} (#${pr.number}) @${pr.user.login}\n`;
                }
                releaseNotes += '\n';
              }
            }
            
            // Add contributors
            const contributors = new Set();
            for (const pr of mergedPRs) {
              contributors.add(pr.user.login);
            }
            
            if (contributors.size > 0) {
              releaseNotes += `## ðŸ‘¥ Contributors\n\n`;
              releaseNotes += `Thanks to all contributors: ${[...contributors].map(c => `@${c}`).join(', ')}\n\n`;
            }
            
            releaseNotes += `---\n_Generated by PAF Release Notes Action_`;
            
            // Update release with notes
            try {
              const { data: release } = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tag
              });
              
              await github.rest.repos.updateRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: release.id,
                body: releaseNotes
              });
              
              console.log('Release notes updated successfully');
            } catch (error) {
              console.log('Creating new release...');
              await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: tag,
                name: `Release ${tag}`,
                body: releaseNotes
              });
            }
